# -*- coding: utf-8 -*-
"""task2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UePPMwRLc5EjyKlNCDP9Tom2g7O1u3Rd
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

!pip install chardet

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import chardet

# Load a dataset from your drive (example with a CSV file)
file_path = '/Sample - Superstore.csv'  # Change this to your file path

# Detect the encoding of the file
with open(file_path, 'rb') as f:
    result = chardet.detect(f.read())
encoding = result['encoding']

# Read the CSV file using the detected encoding
data = pd.read_csv(file_path, encoding=encoding)
data.head()

import pandas as pd

# Load the dataset, specifying the encoding
data = pd.read_csv("/Sample - Superstore.csv", encoding='latin-1')  # or 'ISO-8859-1', or other encodings
print(data.head())  # Display first 5 rows
print(data.info())  # Check data types and non-null counts
print(data.describe())  # Summarize numeric columns

# Descriptive statistics for numerical coulumns.
data.describe().T

data.describe(include='all').T

print(data.isnull().sum())  # Counts missing values in each column

data["Order Date"] = pd.to_datetime(data["Order Date"])

data["Ship Date"] = pd.to_datetime(data["Ship Date"])

data["order_month"] = pd.to_datetime(data["Order Date"]).dt.month_name()

data["order_year"] = pd.to_datetime(data["Order Date"]).dt.year

data["Ship_month"] = pd.to_datetime(data["Ship Date"]).dt.month_name()

data["Ship_year"] = pd.to_datetime(data["Ship Date"]).dt.year

data.sample(n=1)

data.info()

#Exploitary Data Analysis

# Ensure 'Order Date' column is datetime type
data['Order Date'] = pd.to_datetime(data['Order Date'])

# Extract the month from the 'Order Date' and create a new column 'order_month'
data['order_month'] = data['Order Date'].dt.month

# Now, you should be able to group by 'order_month'
monthly_sales = data.groupby("order_month")["Sales"].sum().reset_index().sort_values(by='Sales',ascending=False)

# Calculating Monthly Sales.
monthly_sales = data.groupby("order_month")["Sales"].sum().reset_index().sort_values(by='Sales',ascending=False)

monthly_sales

import matplotlib.pyplot as plt # Importing the matplotlib library for creating visualizations.
import seaborn as sns # Importing the seaborn library for enhanced visualizations.


plt.title("Graph displaying Monthly Sales") # Setting the title of the plot.
sns.lineplot(monthly_sales,x = "order_month",y="Sales") # Creating a line plot using seaborn.
plt.xticks(rotation = 75) # Rotating x-axis labels for better readability.
plt.show() # Displaying the plot.

# Sales on the basis of Category
category_sales = data.groupby('Category')["Sales"].sum()

category_sales

plt.title("Sales by each Category")
colors = sns.color_palette('pastel')[0:len(category_sales)]
plt.pie(category_sales,labels=category_sales.index, autopct='%1.1f%%',colors=colors)

#sales per Sub-Category
Sub_category_sales = data.groupby('Sub-Category')["Sales"].sum().reset_index()

Sub_category_sales

plt.title("Sales by Sub Category")
sns.barplot(Sub_category_sales,x = 'Sub-Category',y='Sales')
plt.xticks(rotation = 75)

#profit analysis

# Profit's earned each month.
monthly_profit = data.groupby("order_month")["Profit"].sum().reset_index()

monthly_profit

plt.title("Profit's earned each month")
sns.lineplot(monthly_profit,x="order_month",y = "Profit")
plt.xticks(rotation = 75)

#Profit's earned by each category.
category_profits = data.groupby("Category")["Profit"].sum()

plt.title("Profits by Category")
colors = sns.color_palette('pastel')[3:7]
plt.pie(category_profits,labels=category_profits.index,autopct='%1.1f%%',colors=colors)

# Profit's earned by each sub category
sub_profit = data.groupby("Sub-Category")["Profit"].sum().reset_index()

sub_profit

plt.title("Profit Analysis by Sub Category")
sns.barplot(sub_profit,x = "Sub-Category",y = "Profit")
plt.xticks(rotation = 75)

#Sales-Profit Comparison w.r.t Segment
segment = data.groupby("Segment")[["Sales","Profit"]].sum()
segment

plt.figure(figsize=(12, 6))
segment.plot(kind='bar')
plt.title("Sales-Profit Comparison per segment")
plt.xlabel("Segments")
plt.ylabel("Sales,Profit")

# Plotting a PairPlot
sns.pairplot(data,vars=['Sales', 'Quantity', 'Discount', 'Profit','order_month'], hue='order_month')

# Shape of the DataFrame
data.shape

# Clubbing all Numerical Columns
Num1 = data[['Row ID',  'Postal Code','Sales', 'Quantity', 'Discount', 'Profit', 'Ship Date']]

#sales per Sub-Category
Sub_category_sales = data.groupby('Sub-Category')["Sales"].sum().reset_index()

Sub_category_sales

# Clubbing all Categorical Columns
Cat1 = data[['Order ID', 'Order Date', 'Ship Date', 'Ship Mode',
       'Customer ID', 'Customer Name', 'Segment', 'Country', 'City', 'State',
        'Region', 'Product ID', 'Category', 'Sub-Category', 'order_month',
       'Product Name']] # Removed 'Ship_month' as it is not present in the DataFrame.

columns = data[['Row ID', 'Sales', 'Quantity', 'Discount', 'Profit']]
columns.info()

!pip install pandas

import pandas as pd

# Assuming Num1 is your DataFrame
# Select only the numeric columns before calculating the correlation
numeric_columns = Num1.select_dtypes(include=['number']).columns
corr_matrix = Num1[numeric_columns].corr()

# Plot the correlation matrix using a heatmap
import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(8, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f')

# Using Box-Plot to find outliers if any in the Numerical Columns
for col in Num1.columns:
    sns.boxplot(x = Num1[col],showmeans = True)



    plt.show()

# Using exponential method to reduce outliers
import numpy as np # Import numpy and define the alias 'np'
exp = data[[ 'Sales', 'Quantity', 'Discount', 'Profit']]
np.exp(exp["Sales"])

# Using for-loop for reducing treatment
for i in exp.columns:
    exp[i] = np.exp(exp[i])
    exp.head()

# Replacing the values of Num1 dataframe with exponential values.
Num1[[ 'Sales', 'Quantity', 'Discount', 'Profit']] = exp[[ 'Sales', 'Quantity', 'Discount', 'Profit']]

Num1

Mod1 = Num1

Cat1.columns

Mod1["Region"] = Cat1["Region"]

mod1 = data[[ 'Ship Mode','Segment', 'City', 'State', 'Region', 'Category', 'Sub-Category', ]]

Mod1[['Sales', 'Quantity', 'Discount', 'Profit',"Ship_year"]] = Num1[['Sales', 'Quantity', 'Discount', 'Profit',"Ship Date"]]

Mod1[['Ship Mode',
        'Segment', 'Country', 'City', 'State', 'Region',
       'Category', 'Sub-Category']] = Cat1[['Ship Mode',
        'Segment', 'Country', 'City', 'State', 'Region',
       'Category', 'Sub-Category']]

Mod1.sample(n = 5)

# All the Features to be used in the model.
Mod1.columns

# Import LabelEncoder from sklearn.preprocessing
from sklearn.preprocessing import LabelEncoder

# Now you can create an instance:
labelencoder = LabelEncoder()

for i in Mod1.columns:
    Mod1[i] = labelencoder.fit_transform(Mod1[i])

# Preparing X & y for model execution
# y contains Target Vatiable
y = Mod1["Profit"]

# X contains Independent Variables
X = Mod1.drop(columns='Profit')

X

# Dropping Country Column since the Data is of only united States
X.drop(columns='Country',inplace=True)

# Import the necessary module
from sklearn.model_selection import train_test_split

# Using Train-Test Split to split the data in training & testing halves.
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=2)

#importing Linear Regression
from sklearn.linear_model import LinearRegression

regression = LinearRegression()

regression.fit(X_train,y_train)

# Score of the Linear Model built
regression.score(X_test,y_test)

import sklearn.metrics as metrics
ypred = regression.predict(X_test)
r_squared = metrics.r2_score(y_test, ypred)
r_squared

# importing Lasso Regression
from sklearn.linear_model import Lasso
lasso_reg = Lasso()
lasso_reg.fit(X_train,y_train)

# Lasso Model Accuracy
lasso_reg.score(X_test,y_test)

# The line below is incorrect and causes the error
# import Ridge

# Use this line to import the correct module and then access the Ridge class
from sklearn.linear_model import Ridge
ridge_reg = Ridge()
ridge_reg.fit(X_train,y_train)
ridge_reg.fit(X_train,y_train)

# Accuracy of Ridge Regression Model
ridge_reg.score(X_test,y_test)

# importing Random Forest Regressor
from sklearn.ensemble import RandomForestRegressor
rf = RandomForestRegressor(n_estimators=100, random_state=42)
rf.fit(X_train, y_train)

ypred = rf.score(X_test,y_test)
# Accuracy of Random Forest Regressor
ypred

# importing KNN regressor
from sklearn.neighbors import KNeighborsRegressor
knn_reg = KNeighborsRegressor()
knn_reg.fit(X_train, y_train)

# Accuracy of KNN Model
knn_reg.score(X_test,y_test)